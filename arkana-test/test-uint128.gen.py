#!/usr/bin/env python3
import sys
from itertools import product

sys.stdout = open('test-uint128.cpp', 'w', newline='\n')

print('''\
// test-uint128.cpp / generated by
// python3 test-uint128.gen.py

#include "pch.h"

#include "../arkana/bits.h"

using arkana::bits::uint128::uint128_t;
using arkana::bits::uint128::rotl;
using arkana::bits::uint128::rotr;
using arkana::bits::uint128::byteswap;
using namespace arkana::bits::uint128::literals;

static inline uint128_t u128(uint64_t h, uint64_t l)
{
    // little-endian u128
    return arkana::bit_cast<uint128_t>(std::array<uint64_t, 2>{l, h});
}
''')


MASK128 = (1 << 128) - 1
MASK64 = (1 << 64) - 1


bit_patterns = [
    0x00000000000000000000000000000000,
    # 0x000000000000000000000000FFFFFFFF,
    # 0x0000000000000000FFFFFFFF00000000,
    # 0x00000000FFFFFFFF0000000000000000,
    # 0xFFFFFFFF000000000000000000000000,
    # 0x0000000000000000FFFFFFFFFFFFFFFF,
    # 0x00000000FFFFFFFFFFFFFFFF00000000,
    # 0xFFFFFFFFFFFFFFFF0000000000000000,
    # 0xFFFFFFFF0000000000000000FFFFFFFF,
    # 0xFFFFFFFFFFFFFFFFFFFFFFFF00000000,
    # 0x00000000FFFFFFFFFFFFFFFFFFFFFFFF,
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF,
    0x0123456789ABCDEFFEDCBA9876543210,
    0xFEDCBA98765432100123456789ABCDEF,
    0x00112233445566778899AABBCCDDEEFF,
    0xFFEEDDCCBBAA99887766554433221100,
]

test_values = sorted([
    *bit_patterns,
    0x00000000000000000000000000000001,
    0x00000000000000000000000000000002,
    0x000000000000000000000000000000FF,
    0x0000000000000000000000FF00000000,
    0x00000000000000FF0000000000000000,
    0x000000FF000000000000000000000000,
    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE,
])

# shifts = [*range(0, 34), 63, 64, 65, 95, 96, 97, 127, ]
shifts = [*range(0, 128)]
rotates = [*shifts, 128, 129, 255, 256, 257]

bit_pairs = list(product(bit_patterns, bit_patterns))
shift_pairs = list(product(bit_patterns, shifts))
rotate_pairs = list(product(bit_patterns, rotates))
arith_pairs = list(product(test_values, test_values))


def rotl128(a, i):
    return (a << (i & 127) | a >> (-i & 127)) & MASK128


def rotr128(a, i):
    return (a >> (i & 127) | a << (-i & 127)) & MASK128


def byteswap128(a):
    a = (a >> 8 & 0x00FF00FF00FF00FF00FF00FF00FF00FF) | (a & 0x00FF00FF00FF00FF00FF00FF00FF00FF) << 8
    a = (a >> 16 & 0x0000FFFF0000FFFF0000FFFF0000FFFF) | (a & 0x0000FFFF0000FFFF0000FFFF0000FFFF) << 16
    a = (a >> 32 & 0x00000000FFFFFFFF00000000FFFFFFFF) | (a & 0x00000000FFFFFFFF00000000FFFFFFFF) << 32
    a = (a >> 64 & 0x0000000000000000FFFFFFFFFFFFFFFF) | (a & 0x0000000000000000FFFFFFFFFFFFFFFF) << 64
    return a


def str_u128(a): return f'u128({(a >> 64) & MASK64:#018x},{a & MASK64:#018x})'
def str_u128l(a): return f'{a & MASK128:#034x}_u128'
def str_bool(b): return str(b).lower()


def print_test_v(test_name, fun, values):
    print('TEST(uint128, ' + test_name.strip() + ') \n{')
    for x in map(fun, values): print(f"    {x}")
    print('}\n')


def print_test_t(test_name, fun, tuples):
    print_test_v(test_name, lambda x: fun(*x), tuples)

print_test_v("bool ", lambda a: f"EXPECT_EQ(static_cast<bool>({str_u128l(a)}), {str_bool(a != 0)});", test_values)
print_test_v("lnot" , lambda a: f"EXPECT_EQ(!{str_u128l(a)}, {str_bool(a == 0)});", test_values)
print_test_t("eq ", lambda a, b: f"EXPECT_EQ({str_u128l(a)} == {str_u128l(b)}, {str_bool(a == b)});", bit_pairs)
print_test_t("neq", lambda a, b: f"EXPECT_EQ({str_u128l(a)} != {str_u128l(b)}, {str_bool(a != b)});", bit_pairs)
print_test_t("and", lambda a, b: f"EXPECT_EQ({str_u128l(a)} & {str_u128l(b)}, {str_u128(a & b)});", bit_pairs)
print_test_t("or ", lambda a, b: f"EXPECT_EQ({str_u128l(a)} | {str_u128l(b)}, {str_u128(a | b)});", bit_pairs)
print_test_t("xor", lambda a, b: f"EXPECT_EQ({str_u128l(a)} ^ {str_u128l(b)}, {str_u128(a ^ b)});", bit_pairs)
print_test_t("shl", lambda a, i: f"EXPECT_EQ({str_u128l(a)} << {i}, {str_u128(a << i)});", shift_pairs)
print_test_t("shr", lambda a, i: f"EXPECT_EQ({str_u128l(a)} >> {i}, {str_u128(a >> i)});", shift_pairs)
print_test_t("rol", lambda a, i: f"EXPECT_EQ(rotl({str_u128l(a)}, {i}), {str_u128(rotl128(a, i))});", rotate_pairs)
print_test_t("ror", lambda a, i: f"EXPECT_EQ(rotr({str_u128l(a)}, {i}), {str_u128(rotr128(a, i))});", rotate_pairs)
print_test_v("bswap ", lambda a: f"EXPECT_EQ(byteswap({str_u128l(a)}), {str_u128(byteswap128(a))});", bit_patterns)
print_test_t("add", lambda a, b: f"EXPECT_EQ({str_u128l(a)} + {str_u128l(b)}, {str_u128(a + b)});", arith_pairs)
print_test_t("sub", lambda a, b: f"EXPECT_EQ({str_u128l(a)} - {str_u128l(b)}, {str_u128(a - b)});", arith_pairs)
print_test_t("mul", lambda a, b: f"EXPECT_EQ({str_u128l(a)} * {str_u128l(b)}, {str_u128(a * b)});", arith_pairs)
print_test_t("lt ", lambda a, b: f"EXPECT_EQ({str_u128l(a)} < {str_u128l(b)}, {str_bool(a < b)});", arith_pairs)
print_test_t("gt ", lambda a, b: f"EXPECT_EQ({str_u128l(a)} > {str_u128l(b)}, {str_bool(a > b)});", arith_pairs)
print_test_t("ge ", lambda a, b: f"EXPECT_EQ({str_u128l(a)} >= {str_u128l(b)}, {str_bool(a >= b)});", arith_pairs)
print_test_t("le ", lambda a, b: f"EXPECT_EQ({str_u128l(a)} <= {str_u128l(b)}, {str_bool(a <= b)});", arith_pairs)
